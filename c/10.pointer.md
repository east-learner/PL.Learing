##### [c 指针](#top) <b id="top"></b>
`指针是什么东西,它是地址` :star:

------

- [x] [`1.C语言指针的概念`](#target1)
- [x] [`2.指针变量的定义和使用`](#target2)
- [x] [`3.关于 * 和 &`](#target3)
- [x] [`4.指针变量的运算 -- 数组长度求法`](#target4)
- [x] [`5.数组指针`](#target5)
 
------
##### [1.C语言指针的概念](#top) <b id="target1"></b>
`计算机中所有的数据都必须放在内存中，不同类型的数据占用的字节数不一样，例如 int 占用 4 个字节，char 占用 1 个字节。
为了正确地访问这些数据，必须为每个字节都编上号码，就像门牌号、身份证号一样，每个字节的编号是唯一的，根据编号可以准确地找到某个字节。`

`我们将内存中字节的编号称为地址（Address）或指针（Pointer）。地址从 0 开始依次增加，对于 32 位环境，程序能够使用的内存为 4GB，最小的地址为 0，最大的地址为 0XFFFFFFFF`

##### 输出一个地址
`指针本身就是一个地址，获取一个变量的地址需要取地址符号` **`&`**
```c
#include <stdio.h>
int main(){
    int a = 100;
    char str[20] = "c.biancheng.net";
    printf("%#X, %#X\n", &a, str); // 0X60FF0C, 0X60FEF8
    return 0;
}
// %#X 表示以十六进制形式输出，并附带前缀0X
```

```
C语言中有一个控制符%p，专门用来以十六进制形式输出地址，不过 %p 的输出格式并不统一，有的编译器带0x前缀，有的不带
```

##### 一切都是地址
`C语言用变量来存储数据，用函数来定义一段可以重复使用的代码，它们最终都要放到内存中才能供 CPU 使用。`

`数据和代码都以二进制的形式存储在内存中，计算机无法从格式上区分某块内存到底存储的是数据还是代码。当程序被加载到内存后，操作系统会给不同的内存块指定不同的权限，拥有读取和执行权限的内存块就是代码，而拥有读取和写入权限（也可能只有读取权限）的内存块就是数据。`

`CPU 只能通过地址来取得内存中的代码和数据，程序在执行过程中会告知 CPU 要执行的代码以及要读写的数据的地址。如果程序不小心出错，或者开发者有意为之，在 CPU 要写入数据时给它一个代码区域的地址，就会发生内存访问错误。这种内存访问错误会被硬件和操作系统拦截，强制程序崩溃，程序员没有挽救的机会。`

`CPU 访问内存时需要的是地址，而不是变量名和函数名！变量名和函数名只是地址的一种助记符，当源文件被编译和链接成可执行程序后，它们都会被替换成地址。编译和链接过程的一项重要任务就是找到这些名称所对应的地址。`

##### 地址可加减
`假设变量 a、b、c 在内存中的地址分别是 0X1000、0X2000、0X3000，那么加法运算c = a + b;将会被转换成类似下面的形式：`

`C语言的数组就是一个首地址，只要进行加减地址单位就可以访问其他的元素`

```c
#include <stdio.h>
#include <string.h>

int main(){
    char str[20] = "c.jxkicker.com";
    for (int i = 0; i < strlen(str) ; i++)
    {
        printf("%c ", *(str + i));
    }
    return 0;
}
//c . j x k i c k e r . c o m
```
##### [2.C语言指针的概念](#top) <b id="target2"></b>
`数据在内存中的地址也称为指针，如果一个变量存储了一份数据的指针，我们就称它为指针变量。`

`在C语言中，允许用一个变量来存放指针，这种变量称为指针变量。指针变量的值就是某份数据的地址，这样的一份数据可以是数组、字符串、函数，也可以是另外的一个普通变量或指针变量。`

##### 定义指针变量
`定义指针变量与定义普通变量非常类似，不过要在变量名前面加星号*，格式为：`
```
datatype *name;
```

`或者 `

```
datatype *name = value;

//*表示这是一个指针变量，datatype表示该指针变量所指向的数据的类型 。
```

`使用案例`
```c
//定义普通变量
float a = 99.5, b = 10.6;
char c = '@', d = '#';
//定义指针变量
float *p1 = &a;
char *p2 = &c;
//修改指针变量的值
p1 = &b;
p2 = &d;
```

##### 通过指针变量取得数据
`指针变量存储了数据的地址，通过指针变量能够获得该地址上的数据，格式为：`

```
*pointer;
```
`这里的*称为指针运算符，用来取得某个地址上的数据`

```c
#include <stdio.h>
int main(){
    int a = 15;
    int *p = &a;
    printf("%d, %d\n", a, *p);  //两种方式都可以输出a的值
    return 0; // 15, 15
}
```
`从指针取得数据，要先得到指针里面存储的地址再按照地址取得变量的值`

![图像](http://c.biancheng.net/uploads/allimg/190114/1IG3MJ-2.jpg)

`使用指针是间接获取数据，使用变量名是直接获取数据，前者比后者的代价要高。`

##### 指针除了可以获取内存上的数据，也可以修改内存上的数据，例如： 
```c
#include <stdio.h>
int main(){
    int a = 15, b = 99, c = 222;
    int *p = &a;  //定义指针变量
    *p = b;  //通过指针变量修改内存上的数据
    c = *p;  //通过指针变量获取内存上的数据
    printf("%d, %d, %d, %d\n", a, b, c, *p);
    return 0;
}
```

##### [3.关于 * 和 &](#top) <b id="target3"></b>
`假设有一个 int 类型的变量 a，pa 是指向它的指针，那么*&a和&*pa分别是什么意思呢？`

```
*&a可以理解为*(&a)，&a表示取变量 a 的地址（等价于 pa），*(&a)表示取这个地址上的数据（等价于 *pa），
绕来绕去，又回到了原点，*&a仍然等价于 a。
```

```
&*pa可以理解为&(*pa)，*pa表示取得 pa 指向的数据（等价于 a），&(*pa)表示数据的地址（等价于 &a），所以&*pa等价于 pa。 
```

##### 对星号 * 的总结
`在我们目前所学到的语法中，星号*主要有三种用途：`

* [x] `表示乘法，例如int a = 3, b = 5, c;  c = a * b;，这是最容易理解的。`
* [x] `表示定义一个指针变量，以和普通变量区分开，例如int a = 100;  int *p = &a;。`
* [x] `表示获取指针指向的数据，是一种间接操作，例如int a, b, *p = &a;  *p = 100;  b = *p;。`

```c
#include "stdio.h"

int main(int argc, char const *argv[])
{
    float  score = 5.63 , *fp ;
    float * p  = &score;
    *p = 3.14159;
    fp = &*p;
    printf("p: %.4f fp: %.4f \n", *p, *fp);
    printf("p: %#X fp: %#X \n" , p , fp );
    return 0;
}
```
##### [4.指针变量的运算](#top) <b id="target4"></b>
`指针变量保存的是地址，而地址本质上是一个整数，所以指针变量可以进行部分运算，例如加法、减法、比较等`

```c
int a = 5;
int *pa = &a;
```

`以 a 和 pa 为例，a 的类型为 int，占用 4 个字节，pa 是指向 a 的指针，如下图所示：`

![co](http://c.biancheng.net/uploads/allimg/190114/1J0563E7-0.jpg)

```
刚开始的时候，pa 指向 a 的开头，通过 *pa 读取数据时，从 pa 指向的位置向后移动 4 个字节，
把这 4 个字节的内容作为要获取的数据，这 4 个字节也正好是变量 a 占用的内存。
```

`如果pa++;使得地址加 1 的话，就会变成如下图所示的指向关系： 但是这是不成立的 指针的加法 +1 是加了一个单位的类型长度， 例如一个指向 int的指针 加一 由于int的存储长度为四个字节所以，指针实际上加了4 个单位地址 long类型 +1 那么实际上就是加了八个单位地址长度`

![cd](http://c.biancheng.net/uploads/allimg/190114/1J0563064-1.jpg)

`这个时候 pa 指向整数 a 的中间，*pa 使用的是红色虚线画出的 4 个字节，其中前 3 个是变量 a 的，后面 1 个是其它数据的，把它们“搅和”在一起显然没有实际的意义，取得的数据也会非常怪异。`

`如果pa++;使得地址加 4 的话，正好能够完全跳过整数 a，指向它后面的内存，如下图所示：`

![ce](http://c.biancheng.net/uploads/allimg/190114/1J05622E-2.jpg)

`不过C语言并没有规定变量的存储方式，如果连续定义多个变量，它们有可能是挨着的，也有可能是分散的，这取决于变量的类型、编译器的实现以及具体的编译模式，所以对于指向普通变量的指针，我们往往不进行加减运算，虽然编译器并不会报错，但这样做没有意义，因为不知道它后面指向的是什么数据。`

##### 指针的加法 是类型加法
`指针加法和数学运算加法是不一样的`
```c
#include "stdio.h"

int main(int argc, char const *argv[])
{
    float v1 = 5.63, v2 = 9.63, v3 = 98.9;

    float *pv = &v1;
    float *pv2 = &v2;
    
    printf("%#x --( + 1)-> %#x \n", pv, pv + 1); // 指针 加了四个地址单位 一个类型长度
    printf("%#x --( + 1)-> %#x \n", pv2, pv2 + 1);

    int arr[] = { 99, 15, 100, 888, 252 };
    int len = sizeof(arr) / sizeof(int);  //求数组长度
    for(int i=0; i<len; i++){
        printf("Unit address--> %#X : %d \n", (arr + i), *(arr+i) );  //*(arr+i)等价于arr[i]
    } 
    return 0;
}
/*
0x60fef8 --( + 1)-> 0x60fefc 
0x60fef4 --( + 1)-> 0x60fef8 
Unit address--> 0X60FEE0 : 99 
Unit address--> 0X60FEE4 : 15 
Unit address--> 0X60FEE8 : 100 
Unit address--> 0X60FEEC : 888 
Unit address--> 0X60FEF0 : 252 
*/
```

##### 数组长度求法
`sizeof(arr) 会获得整个数组所占用的字节数，sizeof(int) 会获得一个数组元素所占用的字节数`
```c
int lenght = sizeof(array_name) / sizeof(array_type);
```

##### [5.数组指针](#top) <b id="target5"></b>
`数组（Array）是一系列具有相同类型的数据的集合，每一份数据叫做一个数组元素（Element）。数组中的所有元素在内存中是连续排列的，整个数组占用的是一块内存。以int arr[] = { 99, 15, 100, 888, 252 };为例，该数组在内存中的分布如下图所示： `

![cfq](http://c.biancheng.net/uploads/allimg/190114/1J35014B-0.jpg)

`定义数组时，要给出数组名和数组长度，数组名可以认为是一个指针，它指向数组的第 0 个元素。在C语言中，我们将第 0 个元素的地址称为数组的首地址。以上面的数组为例，下图是 arr 的指向：`

![def](http://c.biancheng.net/uploads/allimg/190114/1J3506331-1.jpg)

`数组名的本意是表示整个数组，也就是表示多份数据的集合，但在使用过程中经常会转换为指向数组第 0 个元素的指针，所以上面使用了“认为”一词，表示数组名和数组首地址并不总是等价。初学者可以暂时忽略这个细节，把数组名当做指向第 0 个元素的指针使用即可` **`但是谨记数组名可以理解为指针但是他是一种有类型的指针是指向数组的指针`**

```c
#include "stdio.h"

int main(int argc, char const *argv[])
{
    float v1 = 5.63, v2 = 9.63, v3 = 98.9;
    int arr[] = { 99, 15, 100, 888, 252 };
    int len = sizeof(arr) / sizeof(int);  //求数组长度
    for(int i=0; i<len; i++){
        printf("Unit address--> %#X : %d \n", (arr + i), *(arr+i) );  //*(arr+i)等价于arr[i]
    } 
    return 0;
}
/*
Unit address--> 0X60FEE8 : 99 
Unit address--> 0X60FEEC : 15 
Unit address--> 0X60FEF0 : 100 
Unit address--> 0X60FEF4 : 888 
Unit address--> 0X60FEF8 : 252 
*/
```
